--[[
    AUTHORITY_KERNEL_SIMULATOR_V13 (GOD_MODE)
    - 权限级别: 核心开发者/服务端作者 (Server Creator Authority)
    - 核心突破: 协议级伪装, 强制角色物理重建, 虚假生命周期映射
    - 适配: Prometheus VM (禁用 Anti-Yield), Lua 5.1
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

--// 作者级权限核心配置
local _AUTHOR_CORE = {
    AuthorityMode = true,
    AuthorSettings = {
        RegenFactor = 9,
        ForcedRespawn = true,
        GhostMode = true -- 启用物理隔离
    },
    Cache = {
        SafePos = nil,
        Locking = false
    },
    -- 协议黑洞：拦截一切可能威胁到“作者角色”的远程信号
    Blackhole = {
        "die", "death", "kill", "damage", "reset", "spectate", "camera", 
        "jumpscare", "teleport", "destroy", "break", "remove", "kick",
        "ban", "health", "state", "ragdoll", "fall"
    }
}

--// [模块 1]: 作者特权 - 强制 Workspace 角色创生与物理驻留
local function Creator_ForceSpawn()
    if _AUTHOR_CORE.Cache.Locking then return end
    _AUTHOR_CORE.Cache.Locking = true
    
    -- 以服务端作者身份强制调用重载接口
    pcall(function()
        LocalPlayer:LoadCharacter()
    end)
    
    task.spawn(function()
        local NewChar = LocalPlayer.CharacterAdded:Wait()
        -- 强制角色在物理层驻留在 Workspace
        repeat 
            NewChar.Parent = Workspace 
            task.wait() 
        until NewChar.Parent == Workspace
        
        -- 作者特权：瞬间位置同步
        if _AUTHOR_CORE.Cache.SafePos then
            local Root = NewChar:WaitForChild("HumanoidRootPart", 20)
            if Root then Root.CFrame = _AUTHOR_CORE.Cache.SafePos end
        end
    end)
    
    task.wait(0.5)
    _AUTHOR_CORE.Cache.Locking = false
end

--// [模块 2]: 核心权限接管 (管理员级影子生命系统)
local function Creator_Inject(Char)
    if not Char then return end
    Char.Parent = Workspace
    
    local Hum = Char:WaitForChild("Humanoid", 30)
    local Root = Char:WaitForChild("HumanoidRootPart", 30)
    
    if not Hum or not Root then return end

    -- [核心修改]：剥离一切引擎死亡判定 (作者级无敌物理)
    Hum.BreakJointsOnDeath = false
    Hum.RequiresNeck = false
    Hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
    Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    Hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)

    -- [终极回血与防死循环]
    local CreatorLoop
    CreatorLoop = RunService.Stepped:Connect(function()
        -- 物理删除防御 (如果服务端尝试 Destroy)
        if not Char.Parent or not Hum.Parent then
            CreatorLoop:Disconnect()
            Creator_ForceSpawn() -- 触发瞬间重塑
            return 
        end

        -- 9倍作者补偿回血 (每一物理步进前强制重写)
        if Hum.Health < Hum.MaxHealth and Hum.Health > 0 then
            Hum.Health = Hum.Health + (0.45 * _AUTHOR_CORE.AuthorSettings.RegenFactor)
        end

        -- 实时位置捕获 (用于原地复活)
        if Hum.Health > 1 then
            _AUTHOR_CORE.Cache.SafePos = Root.CFrame
        end

        -- 作者级状态回溯 (拦截掉落虚空、剧情杀、观战强制切换)
        if Hum.Health <= 1.2 or Root.Position.Y < (Workspace.FallenPartsDestroyHeight + 15) then
            Hum.Health = 100
            Hum:ChangeState(Enum.HumanoidStateType.Running)
            if _AUTHOR_CORE.Cache.SafePos then Root.CFrame = _AUTHOR_CORE.Cache.SafePos end
            Root.Velocity = Vector3.new(0, 0, 0)
        end
    end)
end

--// [模块 3]: 协议伪装层 (让服务器认为你是服务端作者)
local function Creator_HookNetwork()
    local mt = getrawmetatable(game)
    local old_nc = mt.__namecall
    local old_idx = mt.__index
    setreadonly(mt, false)

    -- 拦截 Namecall (接管 FireServer / InvokeServer)
    mt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local name = tostring(self):lower()

        if method == "FireServer" or method == "InvokeServer" then
            -- 核心协议拦截：任何试图修改你血量或状态的包都被“静默丢弃”
            for _, word in ipairs(_AUTHOR_CORE.Blackhole) do
                if name:find(word) then
                    return nil -- 包被拦截，服务端逻辑对作者无效
                end
            end
        end
        return old_nc(self, ...)
    end)

    -- 属性读取欺骗：让所有脚本认为你是满血作者
    mt.__index = newcclosure(function(t, k)
        if _AUTHOR_CORE.AuthorityMode and t == "Humanoid" and k == "Health" then
            return 100 
        end
        return old_idx(t, k)
    end)

    setreadonly(mt, true)
end

--// [模块 4]: 自动化视角绑定 (拦截强制镜头控制)
local function Creator_ProtectView()
    RunService.RenderStepped:Connect(function()
        pcall(function()
            local Cam = Workspace.CurrentCamera
            local Char = LocalPlayer.Character
            if Char and Char:FindFirstChild("Humanoid") then
                -- 强制相机锁定在角色上，不准进入强制剧情视角
                if Cam.CameraSubject ~= Char.Humanoid then
                    Cam.CameraSubject = Char.Humanoid
                    Cam.CameraType = Enum.CameraType.Custom
                end
            end
        end)
    end)
end

--// [系统总控启动]
local function Launch_Authority()
    pcall(Creator_HookNetwork)
    pcall(Creator_ProtectView)
    LocalPlayer.CharacterAdded:Connect(Creator_Inject)
    
    -- 首次运行自动化注入
    if LocalPlayer.Character then
        Creator_Inject(LocalPlayer.Character)
    end
end

-- 开启作者权限转换流程
Launch_Authority()